import puppeteer from 'puppeteer';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';

/**
 * Downloads missing protocol PDFs from FormareMedicala.ro
 * Uses the missing-protocols.json file generated by comparison
 */

interface MissingProtocol {
  code: string;
  title: string;
  pdfUrl: string;
}

async function downloadMissingPDFs() {
  // Load missing protocols
  const missingProtocols = JSON.parse(
    readFileSync('data/missing-protocols.json', 'utf-8')
  ) as MissingProtocol[];

  console.log(`Found ${missingProtocols.length} missing protocols to download\n`);

  // Ensure individual PDFs directory exists
  const pdfDir = 'data/pdfs/individual';
  if (!existsSync(pdfDir)) {
    mkdirSync(pdfDir, { recursive: true });
    console.log(`Created directory: ${pdfDir}\n`);
  }

  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });

  const stats = {
    downloaded: 0,
    skipped: 0,
    failed: 0,
    failedCodes: [] as string[]
  };

  try {
    const page = await browser.newPage();
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');

    for (let i = 0; i < missingProtocols.length; i++) {
      const protocol = missingProtocols[i];
      const fileName = `${protocol.code}.pdf`;
      const filePath = join(pdfDir, fileName);

      // Check if already downloaded
      if (existsSync(filePath)) {
        console.log(`[${i + 1}/${missingProtocols.length}] ⏭️  Skipped ${protocol.code} (already exists)`);
        stats.skipped++;
        continue;
      }

      try {
        console.log(`[${i + 1}/${missingProtocols.length}] ⬇️  Downloading ${protocol.code}: ${protocol.title.substring(0, 60)}...`);

        // Navigate to PDF URL
        const response = await page.goto(protocol.pdfUrl, {
          waitUntil: 'networkidle2',
          timeout: 30000
        });

        if (!response || response.status() !== 200) {
          console.log(`   ❌ Failed: HTTP ${response?.status()}`);
          stats.failed++;
          stats.failedCodes.push(protocol.code);
          continue;
        }

        // Get PDF buffer
        const buffer = await response.buffer();

        if (buffer.length < 1000) {
          console.log(`   ❌ Failed: File too small (${buffer.length} bytes)`);
          stats.failed++;
          stats.failedCodes.push(protocol.code);
          continue;
        }

        // Save PDF
        writeFileSync(filePath, buffer);
        const sizeMB = (buffer.length / 1024 / 1024).toFixed(2);
        console.log(`   ✅ Downloaded: ${sizeMB} MB`);
        stats.downloaded++;

        // Rate limiting - wait 500ms between downloads
        if (i < missingProtocols.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }

      } catch (error: any) {
        console.log(`   ❌ Error downloading ${protocol.code}: ${error.message}`);
        stats.failed++;
        stats.failedCodes.push(protocol.code);
      }
    }

  } catch (error) {
    console.error('Fatal error:', error);
    throw error;
  } finally {
    await browser.close();
  }

  // Print summary
  console.log(`\n=== Download Summary ===`);
  console.log(`Total protocols: ${missingProtocols.length}`);
  console.log(`✅ Downloaded: ${stats.downloaded}`);
  console.log(`⏭️  Skipped (already exists): ${stats.skipped}`);
  console.log(`❌ Failed: ${stats.failed}`);

  if (stats.failedCodes.length > 0) {
    console.log(`\nFailed codes: ${stats.failedCodes.join(', ')}`);
  }

  // Save download stats
  writeFileSync(
    'data/download-stats.json',
    JSON.stringify({
      timestamp: new Date().toISOString(),
      ...stats
    }, null, 2)
  );
  console.log(`\n✓ Saved download statistics to data/download-stats.json`);

  return stats;
}

downloadMissingPDFs()
  .then(stats => {
    console.log(`\n✓ Download complete`);
    console.log(`Next step: Extract and import ${stats.downloaded} protocols into database`);
    process.exit(0);
  })
  .catch(error => {
    console.error('\n✗ Download failed:', error);
    process.exit(1);
  });
